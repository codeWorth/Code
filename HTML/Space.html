<!DOCTYPE html>
<html>
	<head>
		<title>Space</title>
		<style type="text/css">
			#mainCanv{
				background-color:black;
			}
		</style>
	</head>
	<body>
		<canvas id="mainCanv" width="1400" height="750"></canvas>
		<script type="text/javascript">
			var mainCanv = document.getElementById("mainCanv");
			var ctx = mainCanv.getContext("2d");

			var gridSpace = 75;

			var worldWidth = 10000;
			var worldHeight = 10000;

			var canvWidth = mainCanv.width;
			var canvHeight = mainCanv.height;

			var thrusterRadius = 3;

			//character
			var centerX = 18; //approximate values, dependent on draw func
			var centerY = 24;
			var charX = worldWidth/2;
			var charY = worldHeight/2;
			var rotation = 0;
			var totalMass = 30;
			var charModel;
			var omega = 0; //angular velocity
			var vX = 0; //linear x vel
			var vY = 0; //linear y vel

			var leftForwardEngine = {x:3, y:42, fX:0, fY:-5};
			var rightForwardEngine = {x:33, y:42, fX:0, fY:-5};

			var backwardsEngine = {x:18, y:5, fX:0, fY:5};

			var dT = 0.3; //timestep

			function Planet(x, y, r, color) {
				this.x = x;
				this.y = y;
				this.r = r;
				this.color = color;
			}
			var planets = [new Planet(4500, 4500, 30, “red”), new Planet(2500, 2500, 50, “green”), new Planet(4500, 6000, 20, “lightBlue”)];

			var aDown = false;
			var dDown = false;
			var wDown = false;
			var sDown = false;

			var init;

			var onscreenX = canvWidth/2 - 5;
			var onscreenY = canvHeight/2 - 5;

			function renderFunction(width, height, renderFunction) {
			    var buffer = document.createElement('canvas');
			    buffer.width = width;
			    buffer.height = height;
			    renderFunction(buffer.getContext('2d'));
			    return buffer;
			}

			//create character models
			charModel = renderFunction(40, 50, function (ctx){
				ctx.beginPath();
				ctx.moveTo(3,42);
				ctx.lineTo(18,5);
				ctx.lineTo(32,42);
				ctx.arc(18,46,15,0-Math.PI/7,8*Math.PI/7,true);
				ctx.closePath();
				ctx.strokeStyle = "white";
				ctx.lineWidth = 3;
				ctx.stroke();
			});

			ctx.drawImage(charModel, canvWidth/2, canvHeight/2);

			function drawPlanets(x, y){
				var leftX = x - canvWidth/2;
				var topY = y - canvHeight/2;

				var thisPlanet;

				for (var i = 0; i < planets.length; i++){
					thisPlanet = planets[i];
					if (thisPlanet.x > leftX - thisPlanet.r && thisPlanet.x < leftX + canvWidth + thisPlanet.r && thisPlanet.y > topY - thisPlanet.r && thisPlanet.y < topY + canvHeight + thisPlanet.r){
						ctx.beginPath();
						ctx.moveTo(thisPlanet.x, thisPlanet.y);
						ctx.arc(thisPlanet.x, thisPlanet.y, thisPlanet.r, 0, Math.PI*2, true);
						ctx.closePath();
						ctx.fillStyle = thisPlanet.color;
						ctx.fill();
					}
				}
			}

			function drawGrid(x,y){
				var xOff = (x - canvWidth/2) % gridSpace;
				var yOff = (y - canvHeight/2) % gridSpace;

				var xLinesToDraw = canvWidth/gridSpace;
				var yLinesToDraw = canvHeight/gridSpace;

				ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
				ctx.lineWidth = 2;

				ctx.beginPath();

				for (var i = -1; i < xLinesToDraw + 1; i++){
					ctx.moveTo(gridSpace*i - xOff, 0);
					ctx.lineTo(gridSpace*i - xOff, canvHeight);
				}

				for (var i = -1; i < yLinesToDraw + 1; i++){
					ctx.moveTo(0, gridSpace*i - yOff);
					ctx.lineTo(canvWidth, gridSpace*i - yOff);
				}

				ctx.moveTo(xOff, 0);
				ctx.closePath();

				ctx.stroke();

				ctx.beginPath();
				ctx.lineWidth = 1;
				ctx.strokeStyle = "white";

				if (y < canvHeight/2){ //upper left corner
					ctx.moveTo(0, canvHeight/2 - y);
					ctx.lineTo(canvWidth, canvHeight/2 - y);
					ctx.moveTo(0, canvHeight/2 - y);
				} else if (y > worldHeight - canvHeight/2) { //lower left corner
					ctx.moveTo(0, worldHeight + canvHeight/2 - y);
					ctx.lineTo(canvWidth, worldHeight + canvHeight/2 - y);
					ctx.moveTo(0, worldHeight + canvHeight/2 - y);
				}

				if (x < canvWidth/2){
					ctx.moveTo(canvWidth/2 - x, 0);
					ctx.lineTo(canvWidth/2 - x, canvHeight);
					ctx.moveTo(canvWidth/2 - x, 0);
				} else if (x > worldWidth - canvWidth/2){
					ctx.moveTo(worldWidth + canvWidth/2 - x, 0);
					ctx.lineTo(worldWidth + canvWidth/2 - x, canvHeight);
					ctx.moveTo(worldWidth + canvWidth/2 - x, 0);
				}

				ctx.closePath();
				ctx.stroke();
			}

			function checkKeysDown(e){
				if (e.keyCode == 65){
					aDown = true;
				}
				if (e.keyCode == 68){
					dDown = true;
				}
				if (e.keyCode == 87){
					wDown = true;
				}
				if (e.keyCode == 83){
					sDown = true;
				}
			}

			function checkKeysUp(e){
				if (e.keyCode == 65){
					aDown = false;
				}
				if (e.keyCode == 68){
					dDown = false;
				}
				if (e.keyCode == 87){
					wDown = false;
				}
				if (e.keyCode == 83){
					sDown = false;
				}
			}

			function applyForce(fCX, fCY, fX, fY, mFC){ //fCX and FCY are the distances from point of force to center of mass. fX and fY is the force. Returns an object: {projX:..., projY:..., orth:..., r:...} Towards is the amount of force towards the center of mass, normal is the amount normal to it, r is the distance from the force to the center. Also takes magnitude of FC, which is optional. It will be ignored if it is 0.
				//rotate force vectors for direction of ship

				var mag = 1;
				if (mFC === 0){
					var magSquared = fCX*fCX + fCY*fCY;
					if (magSquared === 0){
						return false;
					} else {
						mag = Math.sqrt(magSquared);
					}
				} else {
					mag = mFC;
				}

				var dot = fX*fCX + fY*fCY;
				var proj = dot/mag;

				var orth = Math.sqrt (fX*fX + fY*fY - proj*proj);
				var crossZ = fCX*fY - fCY*fX;
				if (crossZ < 0){
					orth *= -1;
				}

				var projX = proj/mag * fCX;
				var projY = proj/mag * fCY;

				changeVels(projX, projY, orth, mag);

				/*
				dot product = fX*fCX + fY*fCY

				projection of f onto fC = dot product / magnitude fC
				orthagonal of f onto fC = sqrt (magSquared - proj*proj)
				*/
			}

			function changeVels(projX, projY, orth, r){
				//w looks kinda like omega :P
				//l means linear
				var aW = orth/totalMass;
				var aLX = projX/totalMass;
				var aLY = projY/totalMass; 

				var dir = Math.atan2(aLY, aLX);
				var len = Math.sqrt(aLX*aLX + aLY*aLY);

				aLX = len * Math.cos(dir + rotation + Math.PI*2);
				aLY = len * Math.sin(dir + rotation + Math.PI*2);

				omega += aW*dT/r;
				vX += aLX*dT;
				vY += aLY*dT;
			}

			function update(){
				ctx.clearRect(0,0,canvWidth,canvHeight);
				var buffer = document.createElement('canvas');
			   	buffer.width = charModel.width;
			    	buffer.height = charModel.height;
			  	bufferCtx = buffer.getContext('2d');

				drawPlanets(charX, charY);
				
				if (wDown && !aDown && !dDown){
					applyForce(leftForwardEngine.x-centerX, leftForwardEngine.y-centerY, leftForwardEngine.fX, leftForwardEngine.fY, 0);
					applyForce(rightForwardEngine.x-centerX, rightForwardEngine.y-centerY, rightForwardEngine.fX, rightForwardEngine.fY, 0);

					bufferCtx.fillStyle = "red";
					bufferCtx.beginPath();
					bufferCtx.moveTo(leftForwardEngine.x, leftForwardEngine.y);
					bufferCtx.arc(leftForwardEngine.x, leftForwardEngine.y, thrusterRadius, 0, Math.PI*2, true);
					bufferCtx.moveTo(rightForwardEngine.x, rightForwardEngine.y);
					bufferCtx.arc(rightForwardEngine.x, rightForwardEngine.y, thrusterRadius, 0, Math.PI*2, true);
					bufferCtx.closePath();
					bufferCtx.fill();
				}
				if (sDown){
					applyForce(backwardsEngine.x-centerX, backwardsEngine.y-centerY, backwardsEngine.fX, backwardsEngine.fY, 0);

					bufferCtx.fillStyle = "red";
					bufferCtx.beginPath();
					bufferCtx.moveTo(backwardsEngine.x, backwardsEngine.y);
					bufferCtx.arc(backwardsEngine.x, backwardsEngine.y, thrusterRadius, 0, Math.PI*2, true);
					bufferCtx.closePath();
					bufferCtx.fill();
				}
				if (dDown){
					applyForce(leftForwardEngine.x-centerX, leftForwardEngine.y-centerY, leftForwardEngine.fX, leftForwardEngine.fY, 0);

					bufferCtx.fillStyle = "red";
					bufferCtx.beginPath();
					bufferCtx.moveTo(leftForwardEngine.x, leftForwardEngine.y);
					bufferCtx.arc(leftForwardEngine.x, leftForwardEngine.y, thrusterRadius, 0, Math.PI*2, true);
					bufferCtx.closePath();
					bufferCtx.fill();
				}
				if (aDown){
					applyForce(rightForwardEngine.x-centerX, rightForwardEngine.y-centerY, rightForwardEngine.fX, rightForwardEngine.fY, 0);

					bufferCtx.fillStyle = "red";
					bufferCtx.beginPath();
					bufferCtx.moveTo(rightForwardEngine.x, rightForwardEngine.y);
					bufferCtx.arc(rightForwardEngine.x, rightForwardEngine.y, thrusterRadius, 0, Math.PI*2, true);
					bufferCtx.closePath();
					bufferCtx.fill();
				}

				charX += vX;
				charY += vY;
				rotation += omega;

				drawRotatedImage(charModel, onscreenX, onscreenY, rotation);
				drawRotatedImage(buffer, onscreenX, onscreenY, rotation);

				drawGrid(charX,charY);
			}

			function drawRotatedImage(image, x, y, angle) { 
			 
				// save the current co-ordinate system 
				// before we screw with it
				ctx.save(); 
			 
				// move to the middle of where we want to draw our image
				ctx.translate(x, y);
			 
				// rotate around that point
				ctx.rotate(angle);
			 
				// draw it up and to the left by half the width
				// and height of the image 
				ctx.drawImage(image, -(image.width/2), -(image.height/2));
			 
				// and restore the co-ords to how they were when we began
				ctx.restore(); 
			}

			init = setInterval(update, 20);

			document.body.onkeydown = checkKeysDown;
			document.body.onkeyup = checkKeysUp;
		</script>
	</body>
</html>
